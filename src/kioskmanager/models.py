from django.db import models
from django.conf import settings # To access AUTH_USER_MODEL
from django.core.exceptions import ValidationError
from django.utils import timezone
import os
import uuid # For browser IDs

class DisplayGroup(models.Model):
    """A group of displays that show the same content playlist."""
    name = models.CharField(max_length=100, unique=True)
    # Link to Django Users who can manage content FOR THIS GROUP
    managers = models.ManyToManyField(
        settings.AUTH_USER_MODEL,
        blank=True,
        related_name='managed_display_groups',
        help_text='Users who can manage content items and playlist for this group.'
    )

    def __str__(self):
        return self.name

class Browser(models.Model):
    """Represents a unique browser/display connecting to the system."""
    # Use UUID for a robust unique ID generated by the frontend
    identifier = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, unique=True)
    name = models.CharField(max_length=100, blank=True, null=True, help_text="Optional friendly name for this browser/display")
    group = models.ForeignKey(DisplayGroup, on_delete=models.SET_NULL, null=True, blank=True, related_name='browsers', help_text="The group this browser belongs to.")
    last_seen = models.DateTimeField(default=timezone.now)

    def __str__(self):
        return self.name or str(self.identifier)

class ContentItem(models.Model):
    """Represents a piece of content, either a video or a website."""
    CONTENT_TYPES = [
        ('video', 'Video'),
        ('website', 'Website'),
    ]
    title = models.CharField(max_length=200)
    content_type = models.CharField(max_length=10, choices=CONTENT_TYPES)

    # Video specific
    video_file = models.FileField(upload_to='content/videos/', blank=True, null=True, help_text="Required if type is 'Video'.")

    # Website specific
    url = models.URLField(max_length=2048, blank=True, null=True, help_text="Required if type is 'Website'.")
    duration = models.PositiveIntegerField(default=30, help_text="Duration in seconds to display (for websites). Required if type is 'Website'.", blank=True, null=True)

    uploaded_at = models.DateTimeField(auto_now_add=True)
    # Note: We don't link directly to DisplayGroup here anymore.
    # The link happens via PlaylistEntry. This allows content reuse.

    def clean(self):
        """Validate that the correct fields are filled based on type."""
        if self.content_type == 'video':
            if not self.video_file:
                raise ValidationError({'video_file': 'Video file is required for content type "Video".'})
            if self.url:
                raise ValidationError({'url': 'URL must be blank for content type "Video".'})
            # Duration is ignored for video (playback handles it) but let's nullify it
            self.duration = None
        elif self.content_type == 'website':
            if not self.url:
                raise ValidationError({'url': 'URL is required for content type "Website".'})
            if not self.duration or self.duration <= 0:
                 raise ValidationError({'duration': 'A positive duration (seconds) is required for content type "Website".'})
            if self.video_file:
                # Ensure file field is cleared if switching type
                self.video_file = None # Or raise ValidationError
                # raise ValidationError({'video_file': 'Video file must be blank for content type "Website".'})
        else:
             raise ValidationError({'content_type': 'Invalid content type selected.'})

    def __str__(self):
        return f"{self.title} ({self.get_content_type_display()})"

    # Handle file deletion on model deletion
    def delete(self, *args, **kwargs):
        if self.content_type == 'video' and self.video_file:
            storage, path = self.video_file.storage, self.video_file.path
            # Check if file exists before trying to delete
            if storage.exists(path):
                 try:
                     storage.delete(path)
                     print(f"Deleted file: {path}") # Logging
                 except Exception as e:
                     print(f"Error deleting file {path}: {e}") # Proper logging needed
        super().delete(*args, **kwargs)


class PlaylistEntry(models.Model):
    """Defines the order of a specific ContentItem within a DisplayGroup."""
    group = models.ForeignKey(DisplayGroup, on_delete=models.CASCADE, related_name='playlist_entries')
    content_item = models.ForeignKey(ContentItem, on_delete=models.CASCADE, related_name='playlist_appearances')
    order = models.PositiveIntegerField(help_text="Determines playback order (lower numbers play first).")

    class Meta:
        ordering = ['group', 'order']
        unique_together = ('group', 'order',) # Ensure order is unique within a group
        # If you want the same item multiple times, remove the unique_together constraint on 'content_item' below
        # unique_together = ('group', 'content_item',) # Prevents adding same item twice to one group

    def __str__(self):
        return f"{self.group.name} - Order {self.order}: {self.content_item.title}"